\section{Implementation Details}

\subsection{Construction of convex regions with IRIS}
\label{IRIS_details}
Following the approach in~\cite{marcucci2023motion}, we manually selected a set of robot configurations around which IRIS-generated convex regions were constructed. We used the \texttt{IrisInConfigurationSpace} implementation from Drake. Given the complexity of the benchmark task—with 18 degrees of freedom and a densely cluttered environment—this manual process was challenging but necessary. Automatic region generation would have been more time-consuming, as it would attempt to build more convex regions around a larger number of configurations. 

The most challenging aspect of the manual process was ensuring that the resulting convex regions formed a connected graph that admitted a collision-free path from the start to the goal configuration. Often, configurations we selected led to disconnected graphs. To address this, we initially generated convex regions around $18$ manually chosen configurations, then extracted a minimal, cycle-free subgraph of $6$ connected regions linking the start and goal. To evaluate scalability and performance in more complex settings, we also tested larger graphs with $12$ and $18$ vertices. Since the same graph is intended to support multiple planning tasks, it may be significantly larger and more complex, therefore it is important to ensure that the motion planning algorithm (GCS) remains effective and scalable in such settings.

The time required to generate IRIS convex regions was significant. Generating $6$ regions took $109.66$ minutes. Expanding this set to $12$ regions---including the original $6$ and $6$ additional ones---took $351.84$ minutes. Generating all $18$ regions took $511.05$ minutes. These measurements reflect sequential execution. While IRIS region generation is inherently parallelizable (one region per thread), the runtime for each region can vary widely. In our experiments, the fastest region was generated in $4.66$ minutes, while the slowest took $75.37$ minutes.

\subsection{Precomputation of PRM roadmaps}

We also precomputed and stored the graph (roadmap) generated by the PRM similar to using IRIS, so that during online planning, the algorithm only needs to perform a graph search. For this experiment, we ran the PRM planner for 10 minutes (600 seconds) for precomputation. We also tested longer durations---20 minutes, 30 minutes, etc.---but found that they did not significantly improve the solution quality. Instead, they increased the planning time because of the larger number of vertices added to the graph. This behavior is expected given the nature of PRM, as it is not an anytime algorithm and does not guarantee better solutions with more computation time.
